# Artifact for "Taking Back Control in an Intermediate Representation for GPU Computing"

## Recommended platform
We have prepared and tested this artifact on Ubuntu 20.04 and Ubuntu 20.10. We recommend that you run the artifact using the same versions. Any other linux distribution should work too, although you may have to change some installation commands to suit your distribution. 

## Files included in the artifact

* README.md - this readme file
* ... - a Docker image
* blah.pdf - Version ... of the SPIR-V specification
* blah.pdf - Version ... of the SPIR-V specification
* blah.pdf - Version ... of the SPIR-V specification
* blah.als - Our Alloy model
* blah.jar - the Alloy Analyzer version XYZ
* blah.ods - a spreadsheet with details of the bugs we found
* blah.tgz - test set ...
* blah.tgz - test set ...
* blah.tgz - test set ...
* blah.tgz - test set ...
* blah.tgz - test set ...

[TODO] a note that they do not need to download all the test sets unless they are interested.

## List of claims

The artifact provides evidence to back up the following claims made in the paper. For each claim, we briefly summarise how the artifact provides supporting evidence.

- **Claim 1:** The SPIR-V specification has been updated to incorporate our notion of structural dominance and related rules.
**Evidence:** We provide PDF copies of the SPIR-V specification before and after our changes, and point out key places where our changes have been applied to the specification.
- **Claim 2:** These definitions and rules are based on a formal model of SPIR-V control flow. expressed in the Alloy modelling language.
**Evidence:** We provide an Alloy file containing our formal model, and walk through some example definitions from this model, showing how they relate to the SPIR-V specification document.
- **Claim 3:** Our Alloy model can be used together with the Alloy analyzer to generate both valid and invalid SPIR-V examples.
**Evidence:** We show how to use our formal model inside the Alloy Analyzer GUI to generate valid and invalid examples.
- **Claim 4:** Alloy performance decreases with the size of the generated CFG (table 3 in paper)
  **Evidence:** We provide a script that demonstrates this.
- **Claim 5:** Our alloy-to-spirv tool facilitates obtaining SPIR-V binary programs from examples generated by our Alloy model. These examples can then be cross-validated using the Khronos validation tool, spirv-val.
**Evidence:** Our Docker image contains the Python sources for alloy-to-spirv and instructions on how to use the tool. We give a worked example using the tool to confirm that spirv-val agrees with our model on the validity status of some examples.
- **Claim 6:** Our spirv-to-alloy tool facilitates obtaining inputs to our Alloy model from SPIR-V examples. 
**Evidence:** Via a Docker image, we provide the source code for spirv-to-alloy, instructions on how to build it from source, and a pre-built binary for the tool. We also provide a worked example on how to use spirv-to-alloy.
- **Claim 7:** spirv-to-alloy allows SPIR-V test cases from the Vulkan Conformance Test Suite to be validated against our Alloy model.
**Evidence:** Our Docker image shows how to scrape examples from the Vulkan test suite and convert them to Alloy using spirv-to-alloy.
- **Claim 8:** We have designed a tool chain implementing our novel control flow graph fleshing technique, to yield executable SPIR-V programs embedded in Amber test cases.
**Evidence:** Our Docker image contains the Python sources associated with our control flow graph fleshing implementation, and instructions for how to use the fleshing tooling in practice.
- **Claim 9:** Fleshing has led to the discovery of a number of SPIR-V compiler bugs.
**Evidence:** Our Docker image includes a build of SwiftShader, a software renderer for Vulkan. This allows us to demonstrate a number of the bugs found by our technique without requiring access to specific GPU hardware. We also provide a spreadsheet with links to the various bugs that we have reported to open source projects.

## Download, installation, and sanity-testing

Before going further, please try the following steps and check that they work. At this point we do not explain the purpose of the steps; we merely want to make sure that your system is compatible with the detailed instructions that follow.

### Get required packages

1. Install Java 8: `sudo apt install openjdk-8-jdk`
2. Check Java version: `java -version`, If your java version is not Java 8, then update your default version: `sudo update-alternatives --config java`
3. Install Docker: `sudo apt install docker.io`

### Check that the Alloy Analyzer GUI works
<!---
[TODO] Vasilis, please provide the bare minimum instructions for getting the Alloy GUI, opening our model in it and making it do something. No need to explain the purpose of the required commands; the point here is just to make sure the evaluators have a machine that's suitable, etc.
-->

[Provide Alloy in the artifact and change links to refer to the .jar]

Validating some of our claims require using the Alloy Analyzer GUI, which you will need to download.

To run the Alloy Analyzer on Mac OS X, just download and open the alloy.dmg file available [here](https://github.com/AlloyTools/org.alloytools.alloy/releases/download/v5.1.0/alloy.dmg). For other platforms, just download the jar file [here](https://github.com/AlloyTools/org.alloytools.alloy/releases/download/v5.1.0/org.alloytools.alloy.dist.jar) (available at [Github Releases](https://github.com/AlloyTools/org.alloytools.alloy/releases) page) then double-click on the jar file, or type:

`java -jar org.alloytools.alloy.dist.jar`

in the console.
To load a model with the Alloy Analyzer, select `File` > `Open` in top toolbar, and in the dialog that opens, browse to and select the `als`-file you want to open.
There will be one entry in the `Execute` menu for each `run`-command of the loaded model shown in the text editor section. If no `run`-command exists in the model, the `Run Default for 4 but 4 int, 4 seq expect 1` will be shown in the `Execute` menu (in this case the Analyzer will look for instances of the model with the size of the domains bounded to four). By selecting any `run`-command from the `Execute` menu, the Alloy Analyser will look for a matching example of the spec and will respond with either “No instance found” or “Instance found”. In the latter case, click the `Show` button from the toolbar, and a new window will open up (the Alloy Visualizer) with a diagram similar to this:

![](https://i.imgur.com/CbSyq0r.png)

You can export the solution visualised to a graphviz diagram or to XML by going to `File` > `Export To` > `Dot...` or `XML...` from the Vizualiser's Menu Bar.

### Download and check that the Docker image works

[TODO] Jack, please provide minimal instructions for launching the docker container and running 1-2 simple, relevant commands inside it. Again, the point is to quickly establish whether there's something horribly wrong.

Python

Amber

Alloy*

We provide a docker image that has all the necessary software pre-installed. For now, let's download the image, check that it can be loaded and run some basic checks to make sure that it works as expected.

0. Download the docker image from [here](https://imperiallondon-my.sharepoint.com/:u:/g/personal/jclark2_ic_ac_uk/ESwzq64_UitNury5bFPwkZYBz9ZTTN5UX5-UEMdMu2OpZg). **TODO: Change this from Onedrive to wherever artifact is hosted.**

1. Load the docker image
``` 
sudo docker load -i /path/to/popl-artifact-latest.tar.gz 
```

2. Get a shell in the docker image:
``` 
sudo docker run -it --entrypoint /bin/bash popl-artifact-final
```

3. Test that Amber and SwiftShader work:
```
/data/git/amber/out/Debug/amber -V
```
You should see the following output:
```
Amber        : e754c90
SPIRV-Tools  : a73e7243
SPIRV-Headers: b42ba6d
GLSLang      : 81cc10a4
Shaderc      : e72186b

Physical device properties:
  apiVersion: 1.2.0
  driverVersion: 20971520
  vendorID: 6880
  deviceID: 49374
  deviceType: cpu
  deviceName: SwiftShader Device (LLVM 10.0.0)
  driverName: SwiftShader driver
  driverInfo: 
  minSubgroupSize: 4
  maxSubgroupSize: 4
  maxComputeWorkgroupSubgroups: 64
  requiredSubgroupSizeStages: vert, frag, comp
End of physical device properties.

Summary: 0 pass, 0 fail
```

4. Check Python works:` python3 -V` should output ` Python 3.8.10`

5. Check that Alloy* works:
```
cd /data/git/spirv-control-flow
mkdir -p fleshing/test_sets/alloy/xml
java -classpath /data/git/alloystar -Xmx3g -Djava.library.path=/data/git/alloystar/amd64-linux -Dout=fleshing/test_sets/alloy/xml -Dquiet=false -Dsolver=minisat -Dhigherorder=true -Dcmd=0 -Diter=false  edu/mit/csail/sdg/alloy4whole/RunAlloy AlloyModel/StructuredDominanceCFG.als
```
You should see output similar to:
```
Running Alloy, using MiniSat on command 0.
11:44:23: Translation took 2.31s (224521 vars, 432 primary vars, 737481 clauses).
Solving took 3.63s.
11:44:26: Solution saved to fleshing/test_sets/alloy/xml/test_0.xml.
```

## The updated SPIR-V specification (Claim 1)

[TODO] Ally to write.

## Our Alloy model and its relationship to the specification (Claim 2)

[TODO] Ally: once Vasilis has revised this, go through and give page numbers in the SPIR-V PDFs.

[TODO] The file "blah.als" in the root of the artifact contains the Alloy model. [In what follows refer to lines in that file.]


To give an insight into how the model’s axioms encode the SPIR-V spec’s ([SPIR-V 1.6r2](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html)) rules, we provide below few of our model’s 26 predicates that capture CFG validity constraints, all of which must hold for a CFG to be deemed valid. 



### Predicate 1

```
pred LoopHeaderStructurallyDominatesContinueTarget
{
	let StructurallyReachableBlock = EntryBlock . *( branch . elems + merge + continue ) |
	StructurallyReachableBlock < : continue in structurallyDominates
}

```
This predicate encodes the requirement that every ([structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable)) [loop header](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#LoopHeader) in the CFG must [structurally dominate](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyDominate) its continue-target [[SPIR-V 1.6r2, §2.11.1]](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html). It works in two steps. On the first line, it defines the set of [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable) blocks as those that can be reached by starting at the `EntryBlock` and then taking zero or more steps, each of which is either a `branch`, `merge`, or `continue`. On the second line, the predicate constructs the set of pairs of blocks (*A*, *B*) where there is a continue-edge from *A* to *B* and *A* is in the set of [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable) blocks (the `<:` syntax restricts the domain of a binary relation). The predicate requires that this set is a subset of (`in`) the structural dominance relation; that is, that *A* structurally dominates *B*. The control flow graph below depicts the `continue`-relation with the [loop header](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#LoopHeader) *A* structurally dominating the corresponding `continue` target *B*.

![](https://i.imgur.com/uFXdyH0.png)





### Predicate 2

```
pred UniqueMergeBlock 
{
	all b : HeaderBlock & StructurallyReachableBlock | no b.merge & ((HeaderBlock & StructurallyReachableBlock) - b).merge
}
```
This predicate encodes the constraint that the merge block declared by a [header block](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#HeaderBlock) must not be a merge block declared by any other [header block](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#HeaderBlock) [[SPIR-V 1.6r2, §2.11.1]](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html). The predicate tells that for every [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable) [header block](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#HeaderBlock) (`&` denotes intersection), e.g., *A* in the CFG above, its merge block, $mb1$, is different from any other [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable) [header block](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#HeaderBlock)’s merge block $mb2$., i.e., $mb1 \cap mb2= \emptyset$.

### Predicate 3

```
pred  BackEdgesBranchToLoopHeader 
{
	ran[backEdge] & StructurallyReachableBlock in LoopHeader & StructurallyReachableBlock 
}
pred OneBackEdgeBranchingToLoopHeader 
{
	all lh :LoopHeader & StructurallyReachableBlock  | one backEdge :> lh
}
```
The two predicates above embody the rule that all [back edges](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#BackEdge) must branch to a [loop header](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#LoopHeader) (encoded by the first predicate) with each [loop header](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#LoopHeader) having exactly one back edge branching to it (encoded by the second predicate) [[SPIR-V 1.6r2, §2.11.1]](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html). The first predicate specifies that every back-edge is pointing to a [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable) [loop header](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#LoopHeader) (i.e., the range for the binary relation `backEdge`  is a subset of the set of all [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable) [loop header](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#LoopHeader)s); the second predicate restricts the number of elements of `backEdge` that end with an element in `LoopHeader` to one.

### Predicate 4

```
pred OpSwitchBlockDominatesAllItsCases 
{
   all sw: (SwitchBlock & StructurallyReachableBlock | (sw <: branch . elems:> ( StructurallyReachableBlock  - sw.merge)) in structurallyDominates
}
```
Here this predicate encodes the rule for structured control-flow constructs that for a switch construct *S* with associated [OpSwitch](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpSwitch) instruction, the [header block](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#HeaderBlock) for *S* must [structurally dominate](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyDominate) every case construct associated with *S* [[SPIR-V 1.6r2, §2.11.3]](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html). The predicate constructs the set of pairs of blocks (*A*, *B*) where there is a branch-edge from *A* to *B* and *A* is in the set of [structurally reachable](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#StructurallyReachable)  [switch headers](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#SwitchHeader) the cases of which (the [OpSwitch](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpSwitch) *Target* or *Default* blocks) are in *B*. The predicate requires that this set is a subset of the structural dominance relation; that is, that *A* structurally dominates *B*.
The figure below is an example of violation of the rule as the switch header 12 does not structurally dominate its case construct 11; it does not even dominate its case construct 10. 

![](https://i.imgur.com/W5BGgQG.png)

## Using our Alloy model to generate valid and invalid examples (Claim 3)

[TODO: includet the jar file and als file in the artifact, and change the instructions to tell the evaluator to use those files.]

### Generating valid examples 

A naive approach for generating a valid example, i.e., one that conforms to all SPIR-V rules, using the Alloy model is to run the [Alloy GUI Analyzer](https://github.com/AlloyTools/org.alloytools.alloy), open the [model](https://github.com/mc-imperial/spirv-control-flow/blob/artifact/AlloyModel/StructuredDominanceCFG.als) and under the `Execute` menu option select `Run Default`. The examples that will be generated using this approach, however, lack interesting stories; they may introduce minimal examples lacking vividness (for e.g., instances with low nesting level) or perhaps larger examples with repeating patterns -- all of them obeying the SPIR-V spec rules, by the way.

To patronise the Alloy Analyzer so that the generated examples are of more interest, we introduce new auxiliary constraints to the model which only cater for the shape of the example and the patterns of the constructs, all being orthogonal to the SPIR-V spec. The constraint below, for e.g., encodes three demands: 
1. the first part models the fact that there should not exist Blocks *A*, *B*, *C*, such that:
     * *B* is the only structural-successor of *A*
     * *A* is the only structural-predecessor of *B*
     * *C* is the only structural-successor of *B*
     * *B* is the only structural-predecessor of *C*  

    **_NOTE:_** The prefix operator # (cardinality) on a relation produces the relation's size.

2. the second part of the constraint instructs Alloy Analyzer to restrict the number of switch-cases to three;
3. on the last line, the constraint prevents parallel edges.

```
pred Vibrant 
{
	all disj A,B,C: Block | not (  #(A. (branchSet + merge + continue) - A) = 1 and B in A.(branchSet + merge + continue)  and 
					#(B.~(branchSet + merge + continue) - B) = 1 and A in B.~(branchSet + merge + continue) and
					#(B. (branchSet + merge + continue) - B) = 1 and C in B. (branchSet + merge + continue) and 
					#(C.~(branchSet + merge + continue) - C) = 1 and B in C.~(branchSet + merge + continue) 
										  )
	all sw: SwitchBlock | #(sw<:branch) <= 3

	all  a,b: Block | #(a<:branch:>b) < 2
}
```

To impose a deeper nesting level setup, we introduce another auxiliary predicate which doesn't allow two outmost constructs. The function `outerInner` defines which constructs are within the body of which other constructs.
```
pred MoreInteresting
{
	all disj h1,h2: HeaderBlock | some (h1+h2).~outerInner
	#LoopHeader > 0
}
```

Once the auxiliary contraints are added, it's time to generate valid instances of the model. By executing the `run`-command below (already included in the Alloy model), for e.g., the Alloy Analyzer will find possible examples (if any) for which all the predicates in the command are satisfiable within the scope used (`for exactly 8 Block`). The predicate `Valid` encodes all the SPIR-V rules, `Vibrant` and `MoreInteresting` rule out some boring patterns, while the rest predicates define the preferred number of the constructs in the examples.

```
run { Valid && Vibrant && MoreInteresting && #LoopHeader=1 && #(SelectionHeader-SwitchBlock)=1 && #SwitchBlock=1 } for exactly 8 Block
```
If an example is found, it can be visualised by clicking on the `Show` button (see below instance). The visualisations then can be written to an XML file (`File`/`Export to`). 

![](https://i.imgur.com/LOWpPLA.png)

[TODO] Can we move this stuff about alloy-to-spirv, spirv-as and spirv-val to later in the artifact, inside Docker? We can say: "We show below, under Claim XXX, how to ..."

Next, use the following command:
```
./alloy-to-spirv/convert.py  <path_to_xml_file>   >   <path_to_asm_file>
```
to convert the generated Alloy example into SPIR-V assembly.

You can then assemble this SPIR-V and check its validity via (using the `spirv-as` and `spirv-val` binaries from the latest release of [SPIR-V Tools](https://github.com/KhronosGroup/SPIRV-Tools)):

```
spirv-as --target-env spv1.3 <path_to_asm_file>  -o  <path_to_spv_file> --preserve-numeric-ids

spirv-val <path_to_spv_file>
```
The assembler, `spirv-as`, reads the assembly language text, and emits the binary form on which operates the validator `spirv-val`. The validator is expected to agree with the Alloy model (i.e., deems the example as valid), otherwise a new bug has been found. 

### Generating invalid examples 

Generating invalid examples is easy; you can negate a subset of predicates from the super-predicate `Valid` (`Valid` is a conjunction over all SPIR-V rules) and then use exactly the same procedure as generating valid examples. Tweaking the `Valid` predicate in the alloy model file as below, will force the Alloy Analyzer to generate an example with a switch-block which does not structurally dominates all its cases. The visualisation of the generated example that follows the predicate, exhibits this behaviour (`SelectionHeader1` does not structurally dominate the case `Block3`). The validator is expected to reject this example.

<pre>
pred Valid { 
	UniqueMergeBlock 
	HeaderBlockStrictlyStructurallyDominatesItsMergeBlock 
	BackEdgesBranchToLoopHeader 
	OneBackEdgeBranchingToLoopHeader 
	LoopHeaderStructurallyDominatesContinueTarget 
	ContinueTargetStructurallyDominatesBackEdge 
	BackEdgeStructurallyPostDominatesContinueTarget 
	ConstructContainsAnotherHeader 
	ValidBreakBlock 
	ValidContinueBlock 
	ValidBranchToOuterOpSwitchMerge 
	InvalidBranchToOuterOpSwitchMerge 
	NobranchBetweenCaseConstructs 
	BranchesBetweenConstructs 
<span style="color:red;font-weight:700;font-size:15px">not    OpSwitchBlockDominatesAllItsCases</span>
	AtMostOneBranchToAnotherCaseConstruct 
	CaseConstructBranchedToByAtMostOneOther 
	OrderOfOpSwitchTargetOperands
	EntryBlockIsNotTargeted 
	OpLoopMergeSecondToLast 
	OpSelectionMergeSecondToLast
	OutDegree 
	MultipleOutEdges 
	ExitingTheConstruct 
	StructurallyAcyclic
	BranchToContinue
}
</pre>

![](https://i.imgur.com/iaARtNK.png)

## Performance of Alloy in relation to CFG size (Claim 4)

[TODO] Jack, at this point can we get them to go into the Docker container?

[TODO] Take text from below about generating examples on command line and in bulk, and then extend it with performance stuff.

## The alloy-to-spirv tool (Claim 5)

[TODO] Vasilis: Use the command line to generate a valid example and an invalid example (maybe the same ones as in Claim 3). Then use alloy-to-spirv to convert each into SPIR-V. Then use spirv-dis to show the disassembly and point out the mege instructions. Then use spirv-val to validate them and confirm that this fits in with our model's validity claims.

### Running Alloy Analyzer from the Command Line

[TODO] Vasilis, at this point could they invoke Alloy from the command line to generate a valid example and an invalid example, push them through alloy-to-spirv and then through spirv-as, and confirm that spirv-val accepts one and rejects the other?

You may want to run Alloy from command-line in which case the [Alloy*](https://github.com/johnwickerson/alloystar) should be installed. Note the absolute paths to the Alloy*.

To generate a valid example on macOS run the following from the command line:

```
java -classpath </path/to/alloystar> -Xmx3g -Djava.library.path=</path/to/alloystar/processor_info> -Dout=</path/where/xml/output/is/written/to> -Dquiet=false -Dsolver=minisat -Dhigherorder=true -Dcmd=0 -Diter=false  edu/mit/csail/sdg/alloy4whole/RunAlloy </path/to/ally/model/StructuredDominanceCFG.als>
```
where processor_info is `amd64-linux` if the platform machine is AMD64"; `x86-linux` if 32-bit architecture linux; `x86-mac` if MacOS; `x86-windows` if win32 and `x86-freebsd` if platform is freebsd7.
The above command will search for the compiled version of the `edu/mit/csail/sdg/alloy4whole/RunAlloy` class and load it; next, it will call the main method passing the model file as argument. 
Note that the Alloy model provided in the Docker image contains already a `run`-command which will be executed upon invoking the Alloy Analyzer from Command Line. The solution will be saved as an XML-file to the folder passed as value of `Dout`, which must exist. 

The procedure for generating a valid example differs from generating invalid one in that in the latter case a subset of predicates from the `Valid` predicate in the model are negated, as described earlier. 


### Generating examples in bulk

By changing the value of `Diter` to `true`, the analyser will iteratively generate all possible instances of the specification (saved as XML files); in this case timeout will come in handy allowing you to run the command with a time limit as follows: 

```
timeout <duration> java -classpath </path/to/alloystar> -Xmx3g -Djava.library.path=</path/to/alloystar/processor_info> -Dout=</path/where/xml/output/is/written/to> -Dquiet=false -Dsolver=minisat -Dhigherorder=true -Dcmd=0 -Diter=true  edu/mit/csail/sdg/alloy4whole/RunAlloy </path/to/ally/model/StructuredDominanceCFG.als>
```
where 'duration' can be a positive integer or a floating-point number, followed by an optional unit suffix:

* s - seconds (default)
* m - minutes
* h - hours
* d - days

When no unit is used, it defaults to seconds. If the duration is set to zero, the associated timeout is disabled.
Running Alloy Analyzer in the terminal on a MacBook Pro i7-1068NG7, for e.g., for 20 seconds (using MiniSat as SAT solver), it generated 796 examples of 8 blocks; took 1,91s to translate the model into a Boolean formula whose satisfying assignments correspond to instances in the model; and the rest of the time was used by the SAT solver to solve the Boolean formula for all the instances. Recall that the scope (8) that bounds the size of the domains is defined in the `run`-command in the model file. The scope can be modified within reasonable limits; the larger the scope, the larger the search space and the slower the analysis will become (even intractable).
 



## The spirv-to-alloy tool (Claim 6)

[TODO] Jack, can you work out which of the bits below to slot in here?

## Converting Vulkan CTS test cases to Alloy using spirv-to-alloy (Claim 7)
One way of generating CFGs is to scrape them from the Vulkan conformance test suite (CTS). Running the commands below will scrape the Vulkan CTS and output Alloy (.als) files to the VulkanCTS directory. Each als file represents one scraped CFG.

``` 
cd /data/git/spirv-control-flow
python3 ./spirv-to-alloy/scrape-vulkan-cts.py VulkanCTS VulkanCTS /data/git/VK-GL-CTS/ /data/glslang/bin/glslangValidator /data/git/SPIRV-Tools/pre-built/tools/spirv-as /data/git/SPIRV-Tools/pre-built/tools/spirv-dis /data/git/spirv-control-flow/spirv-to-alloy/build/src/spirv_to_alloy/spirv-to-alloy
```

Once the als files are generated, we can check that they conform to our Alloy model (i.e. they are valid CFGs) and convert them to the XML representation that our fleshing tool can consume. To begin the validation and XML conversion process, run the following command:

```
python3 isCFGdeemedFeasible.py -a /data/git/spirv-control-flow/VulkanCTS -x /data/git/spirv-control-flow/fleshing/test_sets/vulkan_cts/xml -c /data/git/alloystar --block-limit 40
```

Running this command will take some time (1-2 hours) as Alloy must verify each CFG. If you just want to convert the CFGs into XML, then append the --skip-validation option to the above command and the process should take around 10-15 minutes. You should see output like the following:
```
423 GRAPHS WERE PROCESSED. 0 GRAPHS HAD ERRORS. 392 GRAPHS WERE CHECKED. 0 ARE INFEASIBLE. 31 WERE SKIPPED.
```

The 31 CFGs skipped have more than 40 blocks and would take a relatively long time to verify and convert, so they are skipped to keep the time needed for this example short. You can vary the block limit to see how it affects the verification and conversion time.

Once the process is complete, there should be directories containing xml files in the `./fleshing/test_sets/vulkan_cts/xml directory`.
## Control flow graph fleshing (Claim 8)

*Fleshing* is the process of turning a CFG skeleton into an exectuable program that will follow a predetermined path through that CFG. The fleshing/fleshout.py program is responsible for fleshing an individual CFG. It supports a number of options including:
1. Fleshing a single path executed by a single thread
2. Fleshing with op-phi instructions enabled
3. Fleshing multiple threads that follow independent paths

For the purpose of this explanation, ensure you are in the `/data/git/spirv-control/flow` directory. You should already have completed the Claim 7 section which generated CFG skeletons from the Vulkan CTS. We'll use the CFG in `./fleshing/test_sets/vulkan_cts/xml/s005/test_0.xml`.

### Fleshing a single path
To produce a basic fleshed test case that will have a single thread following a predetermined path, run:
```
python3 fleshing/fleshout.py ./fleshing/test_sets/vulkan_cts/xml/s005/test_0.xml --seed 1
```

This will output both the CFG skeleton as SPIR-V code, followed by the fully fleshed test case in the form of an amber program. Amber is essentially a convenient scripting language for running test cases.
**TODO: Explain the role of amber more clearly and why we generate amber files instead of plain spir-v.**

**TODO: Explain the generated SPIR-V for each fleshing method in more detail.**

### Op-phi instructions
To include op-phi instructions in the fleshed test case, append the --op-phi option. For example:
```
python3 fleshing/fleshout.py fleshing/test_sets/vulkan_cts/xml/s005/test_0.xml --seed 1 --op-phi
```
The output should be similar to the regular fleshing process.
**TODO: Explain the generated SPIR-V for each fleshing method in more detail.**

### Independent Paths
It is possible to have the test case use multiple threads, where each thread will follow an independent path through the control flow graph. Although it is supported, for simplicity we do not use the independent paths option with op-phi instructions. 

In SPIR-V, threads can exist in the x, y and z dimensions of a workgroup, and there can be many workgroups. Similarly, workgroups are organised in the x, y and z dimensions. We provide options to limit the maximum number of threads and workgroups in each dimension as shown below.

To have 2 threads and workgroups in each dimension, run:
```
python3 fleshing/fleshout.py fleshing/test_sets/vulkan_cts/xml/s005/test_0.xml --seed 1 --x-threads 2 --y-threads 2 --z-threads 2 --x-workgroups 2 --y-workgroups 2 --z-workgroups 2
```
This will produce programs with a maximum of 8 threads per workgroup and a maximum of 8 workgroups, giving a total maximum thread count of 64. Since each thread can follow an independent path, there are potentially 64 paths through the control flow graph being explored by this one test case.
**TODO: Explain the generated SPIR-V for each fleshing method in more detail.**

### Fleshing runner
We provide a convenience script `fleshing/fleshing_runner.py` that takes in a folder of CFGs represented as XML files and will automatically produce test cases ready for execution. It can be configured to produce multiple different test cases for the same CFG. To produce a single test case for each CFG from the Vulkan CTS, run:
```
python3 fleshing/fleshing_runner.py fleshing/test_sets/vulkan_cts/xml/ --fleshing-seeds 1
```
The `--fleshing-seeds 1` option ensures each test case is produced with the seed 1. To create more test cases for each CFG, add more seeds, for example, `--fleshing-seeds 1 2 3` will produce three three test cases per CFG. If you don't care about the seeds used, you can simply pass the `--repeats X` flag, which will create `X` test cases for each CFG. 

You can pass the same commands to the `fleshing_runner.py` as passed to `fleshout.py` earlier e.g. you can append `--op-phi` to enable op-phi instructions.

Running the command above should only take a few seconds as the fleshing process is fast. You should see `Produced 391 amber files from 392 xml files` towards the bottom of the output. One XML file is skipped because the CFG either has no exit nodes or none are reachable from the entry point of the SPIR-V program. All test cases are written in the same directory as the corresponding XML file.

### Executing fleshed test cases
To execute the fleshed test cases, we provide an
amber runner. To run it:
```
python3 fleshing/amber_runner.py </path/to/directory/containing/amber/files> <path/to/amber> 
```
In this case:
```
python3 fleshing/amber_runner.py fleshing/test_sets/vulkan_cts/xml/ /data/git/amber/out/Debug/amber 
```
As we used the seed 1 during the fleshing process, the results are deterministic and you should see that there are no errors found.
**TODO: Provide an example of the output that should be seen.**

## Finding compiler bugs using fleshing (Claim 9)

[TODO] Jack, can you work out which of the bits below to slot in here?


## The spirv-to-alloy tool

Instructions on how to go from an OpenGL shader to SPIR-V, then from SPIR-V to Alloy, and use Alloy to confirm the example is valid. (†)

Instructions on how to change the SPIR-V so that it becomes invalid, use spirv-to-alloy and see that it is rejected.

## alloy-to-spirv



## Fleshing

Show how to use the example of (†) with fleshing, using a couple of different strategies.

Show how to scrape the Vulkan CTS to get a set of skeletons.

Show how to use the model to generate skeletons out of thin air.

Provide links to the data sets of skeletons and fleshed examples that we used.

Performance of generating CFGs:

- show a set of options for generating interesting CFGs

- have a script that will generate X examples and report the runtime (**TODO**)

### Setup
We provide a docker image that has all the necessary software pre-installed.

0. Download the docker image from [here](https://imperiallondon-my.sharepoint.com/:u:/g/personal/jclark2_ic_ac_uk/ESwzq64_UitNury5bFPwkZYBz9ZTTN5UX5-UEMdMu2OpZg). **TODO: Change this from Onedrive to wherever artifact is hosted.**

1. Load the docker image
``` 
sudo docker load -i popl-artifact-latest.tar.gz 
```

2. Get a shell in the docker image:
``` 
sudo docker run -it --entrypoint /bin/bash popl-artifact-final
```

### Bugs
Trophy Sheet: https://docs.google.com/spreadsheets/d/1Ovgi4Ylo5lGXc4sCVZoem-YU0qJPS5NXPeEKKj1nFn0/edit#gid=0

We will demonstrate three bugs that we found in the Google SwiftShader driver. We use SwiftShader as an example because it requires no GPU hardware (it runs on the CPU) and it is relatively fast to execute test cases. Run all commands from the `/data/git/spirv-control-flow` directory. 

1. The first bug found is a segfault (crash bug). The bug report is [here](https://issuetracker.google.com/issues/228985910). To trigger this bug, run the following:
```
/data/git/amber/out/Debug/amber fleshing/examples/bugs/reduced-segfault.amber
```
You should see the output `Segmentation fault (core dumped)`.

2. The second bug found is an infinite loop bug. The bug report is [here](https://issuetracker.google.com/issues/228512142). To trigger this bug, run the following:
```
/data/git/amber/out/Debug/amber fleshing/examples/bugs/reduced-infinite-loop.amber
```
You should see that the program hangs. Depending on your exact settings, it may eventually crash with a timeout.

3. The third bug found is a miscompilation bug. The bug report is [here](https://issuetracker.google.com/issues/229123528). To trigger this bug, run the following:
```
/data/git/amber/out/Debug/amber fleshing/examples/bugs/reduced-output-oracle.amber 
```
The output should contain the following:
```
fleshing/examples/bugs/reduced-output-oracle.amber: Line 119: Verifier failed: 0 == 8, at index 0
```
This output indicates a miscompilation bug. In other words, the compiler in the driver did not crash, but instead produced incorrect code. Our oracle expects a particular path to be taken and when that path is not taken, we know there is a miscompilation bug. In this case, the expectation was that block 8 should have been visited first (this is the entry block to the program). However, nothing was written to the output array to record this (the output array is initialized with zeros). This indicates that there is a miscompilation bug, as the compiler in the driver must preserve writes to the output array.

### Test Sets:
1. [Fleshed CTS](https://imperiallondon-my.sharepoint.com/:u:/r/personal/jclark2_ic_ac_uk/Documents/amber_files.tar.gz?csf=1&web=1&e=CcbNio)
2. [Test set 1](https://imperiallondon-my.sharepoint.com/:u:/g/personal/jclark2_ic_ac_uk/EWU9bDMkHCFOuuQSkkK_UdwBOdE4Eat_EI_c-uGcCG0n9w?e=wYXxwQ)
3. [OpPhi Vulkan CTS](https://imperiallondon-my.sharepoint.com/:u:/g/personal/jclark2_ic_ac_uk/EbxFzMGnn5tMgupCVLJGDq8Bxf8Oo2rkj8KUkfUiTwGauQ?e=65wz8j)
4. [OpPhi Third test set](https://imperiallondon-my.sharepoint.com/:u:/g/personal/jclark2_ic_ac_uk/ERUWMRpRFWVMl_A0gJ6zynABeNymnUEfoiUHCYMHdPHV7g?e=wEY7dT)
5. [Independent paths test set (throughput testing)](https://imperiallondon-my.sharepoint.com/:u:/g/personal/jclark2_ic_ac_uk/EeSyKX4zhgtHvFfzZJUStCcBG_XNsvq6_XPJyk5SDfiSlA?e=8ba3Jg). Warning, this will take somewhere between 10 and 39 hours to run.

The test sets above can all be downloaded and copied to the docker container. To copy them, run the following:
```
docker cp /path/to/downloaded/test/cases <docker container id>:/desired/location/in/docker/container 
```
To find the container id, run `docker ps`. You can execute the test cases using the amber runner as normal. For example, to execute Test set 1, which was able to find 3 distinct bugs in SwiftShader, run:
```
python3 fleshing/amber_runner.py /desired/location/in/docker/container /data/git/amber/out/Debug/amber
```
This test set has roughly 23,000 test cases and take about 20 mins to run.
