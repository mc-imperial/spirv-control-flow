# fleshout.py

This tool encodes a run of a CFG either by choosing a random path (optionally of a given length). The path must end in a terminal block. If a path of certain length is asked for, it may minimally extended to make it terminating.


## Usage

```
usage: fleshout.py [-h] [--l L] [--seed SEED] xml

This tool fleshes out xml CFG skeletons generated by Alloy.

positional arguments:
  xml          The xml CFG skeleton generated by Alloy

optional arguments:
  -h, --help   show this help message and exit
  --l L        This is the suggested maximum length of the randomly chosen path: the path may be
               extended minimally to make it terminating.
  --seed SEED  The seed to use for the PNG. This can be used to reproduce paths. To guarantee
               reproducibility the seed should be paired with the exact same path length argument.
```

## Example

The CFG below is a skeleton from [here](https://github.com/KhronosGroup/VK-GL-CTS/blob/master/external/vulkancts/data/vulkan/amber/graphicsfuzz/stable-binarysearch-tree-fragcoord-less-than-zero.amber).

![CFG](test_0.png)


```
python3.9 fleshout.py test_0.xml --l 24 --seed 6179875240267643350
```
generates..

```
#!amber

SHADER compute compute_shader SPIRV-ASM
; Follow the path(s):
; unique path #0: 8 -> 9 -> <10> -> <17> -> 18 -> 19

;
; 2 CFG nodes have OpBranchConditional or OpSwitch as their terminators (denoted <n>): 10 and 17.
;
; To follow these paths, we need to make decisions each time we reach 10 or 17.
; These paths were generated with the seed 6179875240267643350 and have lengths ranging from 6 to 6.
;
; We equip the shader with 2+1 storage buffers:
; - An input storage buffer with the directions for each node 10 or 17
; - An output storage buffer that records the blocks that are executed

; SPIR-V
; Version: 1.3
; Generator: Khronos Glslang Reference Front End; 8
; Bound: 15
; Schema: 0
               OpCapability Shader
               OpMemoryModel Logical GLSL450
               OpEntryPoint GLCompute %7 "main" %local_invocation_idx_var %workgroup_id_var
               OpExecutionMode %7 LocalSize 1 1 1
               
               ; Below, we declare various types and variables for storage buffers.
               ; These decorations tell SPIR-V that the types and variables relate to storage buffers

               OpDecorate %size_1_struct_type BufferBlock
               OpMemberDecorate %size_1_struct_type 0 Offset 0
               OpDecorate %size_1_array_type ArrayStride 4

               OpDecorate %output_struct_type BufferBlock
               OpMemberDecorate %output_struct_type 0 Offset 0
               OpDecorate %output_array_type ArrayStride 4

               OpDecorate %directions_10_variable DescriptorSet 0
               OpDecorate %directions_10_variable Binding 0

               OpDecorate %directions_10_index_variable DescriptorSet 0
               OpDecorate %directions_10_index_variable Binding 1

               OpDecorate %directions_17_variable DescriptorSet 0
               OpDecorate %directions_17_variable Binding 2

               OpDecorate %directions_17_index_variable DescriptorSet 0
               OpDecorate %directions_17_index_variable Binding 3

               OpDecorate %output_variable DescriptorSet 0
               OpDecorate %output_variable Binding 4

               OpDecorate %output_index_variable DescriptorSet 0
               OpDecorate %output_index_variable Binding 5

               OpDecorate %local_invocation_idx_var BuiltIn LocalInvocationIndex
               OpDecorate %workgroup_id_var BuiltIn WorkgroupId

          %1 = OpTypeVoid
          %2 = OpTypeFunction %1
          %3 = OpTypeBool
          %4 = OpTypeInt 32 0
          %5 = OpConstantTrue %3
          %6 = OpConstant %4 0

               %dummy_val = OpConstant %4 666
               %constant_10 = OpConstant %4 10
               %constant_16 = OpConstant %4 16
               %constant_17 = OpConstant %4 17
               %constant_14 = OpConstant %4 14
               %constant_24 = OpConstant %4 24
               %constant_2 = OpConstant %4 2
               %constant_15 = OpConstant %4 15
               %constant_12 = OpConstant %4 12
               %constant_19 = OpConstant %4 19
               %constant_21 = OpConstant %4 21
               %constant_23 = OpConstant %4 23
               %constant_25 = OpConstant %4 25
               %constant_8 = OpConstant %4 8
               %constant_7 = OpConstant %4 7
               %constant_11 = OpConstant %4 11
               %constant_22 = OpConstant %4 22
               %constant_0 = OpConstant %4 0
               %constant_9 = OpConstant %4 9
               %constant_1 = OpConstant %4 1
               %constant_18 = OpConstant %4 18
               %constant_20 = OpConstant %4 20
               %constant_13 = OpConstant %4 13

               ; Declaration of storage buffers for the 2 directions and the output

               %size_1_array_type = OpTypeArray %4 %constant_1
               %size_1_struct_type = OpTypeStruct %size_1_array_type
               %size_1_pointer_type = OpTypePointer Uniform %size_1_struct_type

               %directions_10_variable = OpVariable %size_1_pointer_type Uniform
               %directions_10_index_variable = OpVariable %size_1_pointer_type Uniform
               %directions_17_variable = OpVariable %size_1_pointer_type Uniform
               %directions_17_index_variable = OpVariable %size_1_pointer_type Uniform

               %output_array_type = OpTypeArray %4 %constant_7
               %output_struct_type = OpTypeStruct %output_array_type
               %output_pointer_type = OpTypePointer Uniform %output_struct_type
               %output_variable = OpVariable %output_pointer_type Uniform
               %output_index_variable = OpVariable %size_1_pointer_type Uniform

               %local_int_ptr = OpTypePointer Function %4
               %storage_buffer_int_ptr = OpTypePointer Uniform %4

               %input_int_ptr = OpTypePointer Input %4
               %local_invocation_idx_var = OpVariable %input_int_ptr Input
               %vec_3_input = OpTypeVector %4 3
               %workgroup_ptr = OpTypePointer Input %vec_3_input 
               %workgroup_id_var = OpVariable %workgroup_ptr Input

          %7 = OpFunction %1 None %2

          %8 = OpLabel ; Block$11
               %output_index = OpVariable %local_int_ptr Function %constant_0
               %directions_10_index = OpVariable %local_int_ptr Function %constant_0
               %directions_17_index = OpVariable %local_int_ptr Function %constant_0

               %local_invocation_idx = OpLoad %4 %local_invocation_idx_var
               %x_wg_dim_ptr = OpAccessChain %input_int_ptr %workgroup_id_var %constant_0
               %y_wg_dim_ptr = OpAccessChain %input_int_ptr %workgroup_id_var %constant_1
               %z_wg_dim_ptr = OpAccessChain %input_int_ptr %workgroup_id_var %constant_2
               %x_wg_dim = OpLoad %4 %x_wg_dim_ptr
               %y_wg_dim = OpLoad %4 %y_wg_dim_ptr
               %z_wg_dim = OpLoad %4 %z_wg_dim_ptr
               %z_idx_component = OpIMul %4 %z_wg_dim %constant_1
               %y_idx_component = OpIMul %4 %y_wg_dim %constant_1
               %yz_idx_component = OpIAdd %4 %y_idx_component %z_idx_component
               %workgroup_idx = OpIAdd %4 %yz_idx_component %x_wg_dim

               %workgroup_offset = OpIMul %4 %workgroup_idx %constant_1
               %thread_index_offset = OpIAdd %4 %workgroup_offset %local_invocation_idx

               %directions_10_start_idx_ptr = OpAccessChain %storage_buffer_int_ptr %directions_10_index_variable %constant_0 %thread_index_offset
               %directions_10_offset = OpLoad %4 %directions_10_start_idx_ptr
               %directions_17_start_idx_ptr = OpAccessChain %storage_buffer_int_ptr %directions_17_index_variable %constant_0 %thread_index_offset
               %directions_17_offset = OpLoad %4 %directions_17_start_idx_ptr
               %output_start_idx_ptr = OpAccessChain %storage_buffer_int_ptr %output_index_variable %constant_0 %thread_index_offset
               %output_offset = OpLoad %4 %output_start_idx_ptr

               OpStore %directions_10_index %directions_10_offset
               OpStore %directions_17_index %directions_17_offset
               OpStore %output_index %output_offset

   %temp_8_0 = OpLoad %4 %output_index
   %temp_8_1 = OpAccessChain %storage_buffer_int_ptr %output_variable %constant_0 %temp_8_0
               OpStore %temp_8_1 %constant_8
   %temp_8_2 = OpIAdd %4 %temp_8_0 %constant_1
               OpStore %output_index %temp_8_2
               OpBranch %9


          %9 = OpLabel ; LoopHeader$0
   %temp_9_0 = OpLoad %4 %output_index
   %temp_9_1 = OpAccessChain %storage_buffer_int_ptr %output_variable %constant_0 %temp_9_0
               OpStore %temp_9_1 %constant_9
   %temp_9_2 = OpIAdd %4 %temp_9_0 %constant_1
               OpStore %output_index %temp_9_2
               OpLoopMerge %17 %16 None
               OpBranch %10


         %10 = OpLabel ; Block$3
  %temp_10_0 = OpLoad %4 %output_index
  %temp_10_1 = OpAccessChain %storage_buffer_int_ptr %output_variable %constant_0 %temp_10_0
               OpStore %temp_10_1 %constant_10
  %temp_10_2 = OpIAdd %4 %temp_10_0 %constant_1
               OpStore %output_index %temp_10_2
  %temp_10_3 = OpLoad %4 %directions_10_index
  %temp_10_4 = OpAccessChain %storage_buffer_int_ptr %directions_10_variable %constant_0 %temp_10_3
  %temp_10_5 = OpLoad %4 %temp_10_4
  %temp_10_6 = OpIEqual %3 %temp_10_5 %constant_1
  %temp_10_7 = OpIAdd %4 %temp_10_3 %constant_1
               OpStore %directions_10_index %temp_10_7
               OpBranchConditional %temp_10_6 %11 %17


         %11 = OpLabel ; SelectionHeader$2
               OpSelectionMerge %15 None
               OpSwitch %6 %23 1 %12 2 %12 3 %12 4 %12 5 %12 6 %12 7 %12 8 %12 9 %12 10 %12


         %17 = OpLabel ; SelectionHeader$3
  %temp_17_0 = OpLoad %4 %output_index
  %temp_17_1 = OpAccessChain %storage_buffer_int_ptr %output_variable %constant_0 %temp_17_0
               OpStore %temp_17_1 %constant_17
  %temp_17_2 = OpIAdd %4 %temp_17_0 %constant_1
               OpStore %output_index %temp_17_2
  %temp_17_3 = OpLoad %4 %directions_17_index
  %temp_17_4 = OpAccessChain %storage_buffer_int_ptr %directions_17_variable %constant_0 %temp_17_3
  %temp_17_5 = OpLoad %4 %temp_17_4
  %temp_17_6 = OpIEqual %3 %temp_17_5 %constant_1
  %temp_17_7 = OpIAdd %4 %temp_17_3 %constant_1
               OpStore %directions_17_index %temp_17_7
               OpSelectionMerge %19 None
               OpBranchConditional %temp_17_6 %22 %18


         %23 = OpLabel ; SelectionHeader$1
               OpSelectionMerge %24 None
               OpBranchConditional %5 %25 %24


         %12 = OpLabel ; SelectionHeader$0
               OpSelectionMerge %13 None
               OpBranchConditional %5 %20 %13


         %22 = OpLabel ; Block$6
               OpBranch %19


         %18 = OpLabel ; Block$5
  %temp_18_0 = OpLoad %4 %output_index
  %temp_18_1 = OpAccessChain %storage_buffer_int_ptr %output_variable %constant_0 %temp_18_0
               OpStore %temp_18_1 %constant_18
  %temp_18_2 = OpIAdd %4 %temp_18_0 %constant_1
               OpStore %output_index %temp_18_2
               OpBranch %19


         %25 = OpLabel ; Block$2
               OpBranch %24


         %20 = OpLabel ; Block$0
               OpBranch %13


         %19 = OpLabel ; Block$4
  %temp_19_0 = OpLoad %4 %output_index
  %temp_19_1 = OpAccessChain %storage_buffer_int_ptr %output_variable %constant_0 %temp_19_0
               OpStore %temp_19_1 %constant_19
  %temp_19_2 = OpIAdd %4 %temp_19_0 %constant_2
               OpStore %output_index %temp_19_2
               OpReturn


         %24 = OpLabel ; Block$1
               OpBranch %15


         %13 = OpLabel ; SelectionHeader$4
               OpSelectionMerge %14 None
               OpBranchConditional %5 %21 %14


         %21 = OpLabel ; Block$10
               OpBranch %14


         %14 = OpLabel ; Block$9
               OpBranch %15


         %15 = OpLabel ; Block$8
               OpBranch %16


         %16 = OpLabel ; Block$7
               OpBranch %9

               OpFunctionEnd

 END

 BUFFER directions_10 DATA_TYPE uint32 STD430 DATA 0 END
 BUFFER directions_10_index DATA_TYPE uint32 STD430 DATA 0 END
 BUFFER directions_17 DATA_TYPE uint32 STD430 DATA 0 END
 BUFFER directions_17_index DATA_TYPE uint32 STD430 DATA 0 END

 BUFFER output DATA_TYPE uint32 STD430 SIZE 7 FILL 0
 BUFFER output_index DATA_TYPE uint32 STD430 DATA 0 END

 PIPELINE compute pipeline
   ATTACH compute_shader
   BIND BUFFER directions_10 AS storage DESCRIPTOR_SET 0 BINDING 0
   BIND BUFFER directions_10_index AS storage DESCRIPTOR_SET 0 BINDING 1
   BIND BUFFER directions_17 AS storage DESCRIPTOR_SET 0 BINDING 2
   BIND BUFFER directions_17_index AS storage DESCRIPTOR_SET 0 BINDING 3

   BIND BUFFER output AS storage DESCRIPTOR_SET 0 BINDING 4
   BIND BUFFER output_index AS storage DESCRIPTOR_SET 0 BINDING 5

 END
 RUN pipeline 1 1 1

 EXPECT directions_10 IDX 0 EQ 0
 EXPECT directions_10_index IDX 0 EQ 0
 EXPECT directions_17 IDX 0 EQ 0
 EXPECT directions_17_index IDX 0 EQ 0
 EXPECT output IDX 0 EQ 8 9 10 17 18 19 0
 EXPECT output_index IDX 0 EQ 0
```
# fleshing_runner.py

This tool fleshes out a folder of xml CFG skeletons generated by Alloy. Amber files are generated in the same directory as the xml file they are generated from.


## Usage

```
usage: fleshing_runner.py [-h] [--runner-seed RUNNER_SEED]
                          [--fleshing-seeds FLESHING_SEEDS [FLESHING_SEEDS ...] | --repeats
                          REPEATS]
                          xml_folder

This tool fleshes out a folder of xml CFG skeletons generated by Alloy. Amber files are generated
in the same directory as the xml file they are generated from.

positional arguments:
  xml_folder            The folder containing xml skeletons generated by Alloy. The xml skeletons
                        should be in a file called test_0.xml and the folder containing the xml
                        file should be the name of the skeleton.

optional arguments:
  -h, --help            show this help message and exit
  --runner-seed RUNNER_SEED
                        The seed to use for the PNG in the runner. This can be used to reproduce a
                        particular fleshing run, however it does not affect the seeds used when
                        fleshing individual files. To guarantee reproducibility the seed should be
                        paired with the exact same fleshing seeds.
  --fleshing-seeds FLESHING_SEEDS [FLESHING_SEEDS ...]
                        The seeds used for fleshing. These can be used to reproduce the same paths
                        in the flesher.
  --repeats REPEATS     The number of times fleshing is run per xml file.
```

# amber_runner.py

This tool runs all amber files in a folder.


## Usage

```
usage: amber_runner.py [-h] amber_folder amber_path

Run all amber files in a folder

positional arguments:
  amber_folder  Folder containing amber files.
  amber_path    The absolute path to amber (https://github.com/google/amber)

optional arguments:
  -h, --help    show this help message and exit
```
